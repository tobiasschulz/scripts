#!/usr/bin/perl

$| = 1;

my $lsb = q{### BEGIN INIT INFO
# Provides:       hosts
# Required-Start: $network $remote_fs $syslog
# Required-Stop:  $network $remote_fs $syslog
# Default-Start:  2 3 4 5
# Default-Stop:   0 1 6
# Description:    Host Availability Script
### END INIT INFO
};

use strict;
use warnings;

use Term::ANSIColor qw(:constants :pushpop);

sub init {
	    mkdir "/etc/hosts.d";
}

sub rebuild {
	my $hosts = "";

	open my $f, "<", "/etc/hosts";
	my $line;
	while (defined($line = <$f>)) {
		if ($line =~ /^..hosts.d/ || $line =~ /^..static hosts/) {
			last;
		}
		$hosts .= $line;
	}
	close $f;

	$hosts =~ s/^\s+//igm;
	$hosts =~ s/\s+$//igm;

	open $f, ">", "/etc/hosts" or return; # exit if not root!
	print $f $hosts."\n\n" if $hosts;
	
	my $hostname = hostname();
	
	print $f qq{# static hosts IPv4
127.0.0.1 localhost localhost.localdomain
127.0.1.1 $hostname

# static hosts IPv6
::1 ip6-localhost ip6-loopback
fe00::0 ip6-localnet
ff00::0 ip6-mcastprefix
ff02::1 ip6-allnodes
ff02::2 ip6-allrouters
ff02::3 ip6-allhosts};
	
	print $f "\n\n# hosts.d\n";

    my %hosts = hosts();
	for my $host (keys %hosts) {
		my $ip = $hosts{$host};

		print $f "$ip $host $host.vpn\n";
	}
    my %hosts_real = hosts_real();
	for my $host (keys %hosts_real) {
		my $ip = $hosts_real{$host};

		print $f "$ip $host.real\n";
	}

	close $f;
}

sub hostname {
	open my $f, "<", "/etc/hostname";
	my $hostname = <$f>;
	chomp $hostname;
	close $f;
	return $hostname;
}

sub fqdn {
	open my $f, "<", "/etc/mailname";
	my $hostname = <$f>;
	chomp $hostname;
	close $f;
	return $hostname;
}

sub list {
    my %hosts = hosts();
    for my $host (sort keys %hosts) {
        my $ip = $hosts{$host};
        print "$ip $host\n";
    }
}

sub padding {
	my ($str, $len1) = @_;
	my $len2 = length($str);
	if ($len2 <= $len1) {
		return " " x ($len1-$len2);
	}
	else {
		return "";
	}
}

sub status {
    my %hosts = hosts();
    my @hostnames = sort { [split(/\./, $hosts{$b})]->[0] <=> [split(/\./, $hosts{$a})]->[0] }
                    sort { [split(/\./, $hosts{$a})]->[3] <=> [split(/\./, $hosts{$b})]->[3] }
                    keys %hosts;

    my %ping_ms = ping_ms(map {$hosts{$_}} @hostnames);
	my %services_hash = services();

    for my $host (@hostnames) {
        my $ip = $hosts{$host};
        
        local $Term::ANSIColor::AUTORESET = 1;
        print BLUE "$host";
        print padding($host, 11);
        print " (";
        print YELLOW "$ip";
        print "): ";
        print padding($ip, 15);
        
        my $ping = $ping_ms{$ip};
        
        if ($ping) {
        	print BOLD GREEN "up";
        	print MAGENTA " ".$ping." ms";
	        print padding($ping, 5);
	        
	        my @services = $> ? (keys %{$services_hash{$ip}}) : check_ports($ip);
	        
            if (@services) {
            	my %services_tmp = map {$_ => 1} @services;
            	for my $s (keys %services_tmp) {
            		if ($services_tmp{$s."s"}) {
            			delete $services_tmp{$s."s"};
            			delete $services_tmp{$s};
            			$services_tmp{$s."[s]"} = 1;
            		}
            	}
	            print " (";
	            print join(", ", sort keys %services_tmp);
	            set_services($host, @services);
	            print ")";
	        }
        }
        else {
        	print BOLD RED "down";
        }
        print "\n";
    }
}

sub ping_ms {
	my (@ips) = @_;
	my $ips_arg = join(" ", @ips);
	my $output = `fping -c1 -t1200 $ips_arg 2>/dev/null`;
	my %ping_ms = ();
	for my $line (split(/[\r\n]+/, $output)) {
		if ($line =~ /^([^\s]+?)\s.*?\s([^\s]+?)\sms\s/) {
			$ping_ms{$1} = $2;
		}
	}
	return %ping_ms;
}

sub check_ports {
	my ($ip) = @_;
	my %ports = (
			21 => "ftp", 22 => "ssh:22", 25 => "smtp", 80 => "http", 143 => "imap", 2200 => "ssh:2200",
			2201 => "ssh:2201", 2202 => "ssh:2202", 2203 => "ssh:2203",
			443 => "https", 465 => "smtps", 993 => "imaps", 53 => "dns", 8001 => "lighttpd", 8080 => "http:8080", 8081 => "tail",
			25565 => "minecraft", 10011 => "teamspeak", 5060 => "sip:5060", 5061 => "sip:5061", 64738 => "mumble",
			3306 => "mysql", 17500 => "dropbox",
			5900 => "vnc:0", 5901 => "vnc:1", 5902 => "vnc:2", 5903 => "vnc:3", 5904 => "vnc:4", 5905 => "vnc:5",
	);
	
	my $portlist = join(",", keys %ports);
	my $output = `nmap --host-timeout=500 -sS -oG - -p T:$portlist $ip 2>&1 | egrep '(Ports:)|(root privileges)'`;
	my @running = ();
	
	if ($output =~ /root privileges/) {
		#for my $port (keys %ports) {
		#	my $service = $ports{$port};
		#	if (`nc -z $ip $port && echo true` =~ /true/) {
		#		push @running, $service;
		#	}
		#}
	}
	else {
		$output =~ s/^(.*?)Ports..//igm;
		my @scanresult = map { s/\s+//igm; $_ } split(/,/, $output);
		@running = map { $ports{$_} } map { [split(/\//, $_)]->[0] } grep {/open/} @scanresult;
	}
	
	return @running;
}

sub hosts {
    system("bash -c 'rm -f /etc/hosts.d/*/.??* 2>/dev/null'");
	my %hosts = ();
    for my $host (split /\s+/, `cd /etc/hosts.d/; ls`) {
        chomp $host;

        # skip if host has been deleted
        next if -f "/etc/hosts.d/".$host."/remove";

        open my $h, "<", "/etc/hosts.d/".$host."/ip";
        my $ip = <$h>;
        chomp $ip;
        close $h;

        $hosts{$host} = $ip;
    }
    return %hosts;
}

sub hosts_real {
    system("bash -c 'rm -f /etc/hosts.d/*/.??* 2>/dev/null'");
	my %hosts = ();
    for my $host (split /\s+/, `cd /etc/hosts.d/; ls`) {
        chomp $host;

        # skip if host has been deleted
        next if -f "/etc/hosts.d/".$host."/remove";

		# skip if host has no real ip address
        next if ! -f "/etc/hosts.d/".$host."/ip.real";

        open my $h, "<", "/etc/hosts.d/".$host."/ip.real";
        my $ip = <$h>;
        chomp $ip;
        close $h;

        $hosts{$host} = $ip;
    }
    return %hosts;
}

sub services {
	my %services = ();
	my %ips = hosts();
    for my $host (keys %ips) {
        chomp $host;
        open my $h, "<", "/etc/hosts.d/".$host."/services" or next;
        my @s = <$h>;
        close $h;
        @s = split(/[^a-z0-9:]/, join(" ", @s));
        $services{$ips{$host}} = $services{$host} = {map {$_ => 1} @s};
    }
    return %services;
}

sub set_services {
    my ($host, @services) = @_;
    open my $h, ">", "/etc/hosts.d/".$host."/services" or return;
    print $h join(" ", @services)."\n";
    close $h;
}

sub add {
	my @arg = @_;
	my $ip_file = "ip";
	if (@arg > 0 && $arg[0] eq "real") {
		shift @arg;
		$ip_file = "ip.real"
	}
	if (@arg > 0 && $arg[0] eq "vpn") {
		shift @arg;
		$ip_file = "ip"
	}

	if (scalar @arg == 2) {
	    my $ip = $arg[0];
	    my $host = $arg[1];
	    $ip =~ s/[^a-zA-Z0-9_.-]//igm;
	    $host =~ s/[^a-zA-Z0-9_.-]//igm;
	    if ($ip =~ /[a-zA-Z]/i) {
	    	($host, $ip) = ($ip, $host);
	    }
	    
	    print "IP: " . $ip . "\n";
	    print "Host: " . $host . "\n";
	    
	    mkdir "/etc/hosts.d/".$host;
	    open my $f, ">", "/etc/hosts.d/".$host."/".$ip_file;
	    print $f $ip."\n";
	    close $f;
	}
	else {
		print STDERR "Syntax: $0 add [real|vpn] IP HOST\n";
	}
}

sub sync_dirs {
	my %syncdirs = ();
	my %ips = hosts();
    for my $host (keys %ips) {
        chomp $host;
        open my $h, "<", "/etc/hosts.d/".$host."/sync" or next;
        my %dirs = ();
        for my $line (<$h>) {
        	if ($line =~ /^([^\s]+?)\s*?[=]\s*(.*)\s*/) {
        		$dirs{$1} = $2;
        	}
        }
        close $h;
        $syncdirs{$ips{$host}} = $syncdirs{$host} = {%dirs};
    }
    return %syncdirs;
}

sub sync {
	my %args = map {$_ => 1} @_;
	my %hosts = hosts();
	my %services = services();
	my %syncdirs = sync_dirs();
	
	if (!$args{"pull"} && !$args{"push"}) {
		%args = (%args, "pull" => 1, "push" => 1);
	}
	my $pre = "rsyncmono ";
	my $post = "";
	if ($args{"quiet"}) {
		$pre = "rsync -e 'ssh -oStrictHostKeyChecking=no -oBatchMode=yes ' -za ";
		$post = " 2>/dev/null";
	}
	my $fqdn = "";
	if ($args{"fqdn"}) {
		$fqdn = ".".fqdn();
	}
	my $delete = "";
	if ($args{"delete"}) {
		$delete = " --delete ";
		$pre = "rsync -zav ";
	}
	
	for my $host (keys %hosts) {
		next if (!$services{$host}{"ssh:2200"});
		next if $host eq hostname();
		
		my $ip = $hosts{$host};
		for my $dir (keys %{$syncdirs{hostname()}}) {
			my $localdir = $syncdirs{hostname()}->{$dir};
			my $remotedir = $syncdirs{$ip}->{$dir};
			next if !$remotedir;
			
			if ($args{"push"}) {
				print "$localdir -> $host$fqdn:$remotedir\n";
				system("nc -z $host$fqdn 2200 && " . $pre . $delete . $localdir . "/ " . $host.$fqdn . ":" . $remotedir . "/" . $post);
			}
			if ($args{"pull"}) {
				print "$host$fqdn:$remotedir -> $localdir\n";
				system("nc -z $host$fqdn 2200 && " . $pre . $delete . $host.$fqdn . ":" . $remotedir . "/ " . $localdir . "/" . $post);
			}
		}
	}
}

sub install {
	# do not install anything when run from /etc/init.d !!
	if ($0 =~ /init.d/) {
		return;
	}
		
	{
		system("mv /etc/crontab /etc/crontab.bak; grep -v $0 /etc/crontab.bak | grep -v HOSTS > /etc/crontab");
		open my $f, ">>", "/etc/crontab";
		print $f '*/5 * * * * root $(dirname '.$0.')/update-motd ; $(dirname '.$0.')/update-html'." # HOSTS\n";
		print $f '*/5 * * * * root /etc/init.d/tinc start >/dev/null 2>&1'." # HOSTS\n";
		print $f '0 * * * * root '.$0.' sync >/dev/null 2>&1'." # HOSTS \n";
		close $f;
	}
	unlink("/etc/update-motd.d/10-help-text");
	{
		open my $f, ">", "/etc/update-motd.d/10-hosts";
		print $f q{echo; }.$0.q{ status | perl -n -e 'print "  "; print;' 2>/dev/null}.qq{\n};
		close $f;
		system("chmod 0777 /etc/update-motd.d/10-hosts");
	}
	{
		system("rm /etc/resolv.conf");
		open my $f, ">", "/etc/resolv.conf";
		print $f qq{nameserver 127.0.1.1\nnameserver 8.8.8.8\n};
		close $f;
	}
	{
		system("rm /etc/init.d/hosts");
		open my $f, ">", "/etc/init.d/hosts";
		print $f "#!/bin/bash\n".$lsb."\n".$0.' $*'."\n";
		close $f;
		system("chmod 0777 /etc/init.d/hosts");
		system("update-rc.d hosts defaults 2>&1 | grep -v 'already exist'");
	}
	system("comment-out pam_motd.so /etc/pam.d/*");
}

init;
if (@ARGV && $ARGV[0] eq "add") {
	shift @ARGV;
	add @ARGV;
}
elsif (@ARGV && $ARGV[0] eq "sync") {
	shift @ARGV;
	sync @ARGV;
	rebuild;
}
elsif (@ARGV && $ARGV[0] eq "list") {
	list;
}
elsif (@ARGV && $ARGV[0] eq "status") {
	status;
}
elsif (@ARGV && ($ARGV[0] eq "start" || $ARGV[0] eq "restart" || $ARGV[0] eq "install")) {
    print "Starting hosts script...\n" if $ARGV[0] eq "start";
    print "Restarting hosts script...\n" if $ARGV[0] eq "restart";
	install;
	rebuild;
}
elsif (@ARGV && ($ARGV[0] eq "stop")) {
    print "Stopping hosts script...\n";
    rebuild;
}
else {
	rebuild;
}

1;
