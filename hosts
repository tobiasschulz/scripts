#!/usr/bin/perl

$| = 1;

my $lsb = q{### BEGIN INIT INFO
# Provides:       hosts
# Required-Start: $network $remote_fs $syslog
# Required-Stop:  $network $remote_fs $syslog
# Default-Start:  2 3 4 5
# Default-Stop:   0 1 6
# Description:    Host Availability Script
### END INIT INFO
};

use strict;
use warnings;

use Term::ANSIColor qw(:constants :pushpop);

sub init {
	    mkdir "/etc/hosts.d";
}

sub rebuild {
	my $hosts = "";

	open my $f, "<", "/etc/hosts";
	my $line;
	while (defined($line = <$f>)) {
		if ($line =~ /^..hosts.d/ || $line =~ /^..static hosts/) {
			last;
		}
		$hosts .= $line;
	}
	close $f;

	$hosts =~ s/^\s+//igm;
	$hosts =~ s/\s+$//igm;

	open $f, ">", "/etc/hosts";
	print $f $hosts."\n\n" if $hosts;
	
	my $hostname = hostname();
	
	print $f qq{# static hosts IPv4
127.0.0.1 localhost localhost.localdomain
127.0.1.1 $hostname

# static hosts IPv6
::1 ip6-localhost ip6-loopback
fe00::0 ip6-localnet
ff00::0 ip6-mcastprefix
ff02::1 ip6-allnodes
ff02::2 ip6-allrouters
ff02::3 ip6-allhosts};
	
	print $f "\n\n# hosts.d\n";

    my %hosts = hosts();
	for my $host (keys %hosts) {
		my $ip = $hosts{$host};

		print $f "$ip $host $host.vpn\n";
	}

	close $f;
}

sub hostname {
	open my $f, "<", "/etc/hostname";
	my $hostname = <$f>;
	chomp $hostname;
	close $f;
	return $hostname;
}

sub list {
    my %hosts = hosts();
    for my $host (sort keys %hosts) {
        my $ip = $hosts{$host};
        print "$ip $host\n";
    }
}

sub padding {
	my ($str, $len1) = @_;
	my $len2 = length($str);
	if ($len2 <= $len1) {
		return " " x ($len1-$len2);
	}
	else {
		return "";
	}
}

sub check {
    my %hosts = hosts();
    my @hostnames = sort { [split(/\./, $hosts{$b})]->[0] <=> [split(/\./, $hosts{$a})]->[0] }
                    sort { [split(/\./, $hosts{$a})]->[3] <=> [split(/\./, $hosts{$b})]->[3] }
                    keys %hosts;

    my %ping_ms = ping_ms(map {$hosts{$_}} @hostnames);
	my %services_hash = services();

    for my $host (@hostnames) {
        my $ip = $hosts{$host};
        
        local $Term::ANSIColor::AUTORESET = 1;
        print BLUE "$host";
        print padding($host, 11);
        print " (";
        print YELLOW "$ip";
        print "): ";
        print padding($ip, 15);
        
        my $ping = $ping_ms{$ip};
        
        if ($ping) {
        	print BOLD GREEN "up";
        	print MAGENTA " ".$ping." ms";
	        print padding($ping, 5);
	        
	        my @services = $> ? (keys %{$services_hash{$ip}}) : check_ports($ip);
	        
            if (@services) {
	            print " (";
	            print join(", ", sort @services);
	            set_services($host, @services);
	            print ")";
	        }
        }
        else {
        	print BOLD RED "down";
        }
        print "\n";
    }
}

sub ping_ms {
	my (@ips) = @_;
	my $ips_arg = join(" ", @ips);
	my $output = `fping -c1 -t1200 $ips_arg 2>/dev/null`;
	my %ping_ms = ();
	for my $line (split(/[\r\n]+/, $output)) {
		if ($line =~ /^([^\s]+?)\s.*?\s([^\s]+?)\sms\s/) {
			$ping_ms{$1} = $2;
		}
	}
	return %ping_ms;
}

sub check_ports {
	my ($ip) = @_;
	my %ports = (
			21 => "ftp", 22 => "ssh", 25 => "smtp", 80 => "http", 143 => "imap", 
			443 => "https", 465 => "smtps", 993 => "imaps", 53 => "dns",
			25565 => "minecraft", 10011 => "teamspeak",
			3306 => "mysql",
			5900 => "vnc:0", 5901 => "vnc:1", 5902 => "vnc:2", 5903 => "vnc:3", 5904 => "vnc:4", 5905 => "vnc:5",
	);
	
	my $portlist = join(",", keys %ports);
	my $output = `nmap --host-timeout=500 -sS -oG - -p T:$portlist $ip 2>&1 | egrep '(Ports:)|(root privileges)'`;
	my @running = ();
	
	if ($output =~ /root privileges/) {
		#for my $port (keys %ports) {
		#	my $service = $ports{$port};
		#	if (`nc -z $ip $port && echo true` =~ /true/) {
		#		push @running, $service;
		#	}
		#}
	}
	else {
		$output =~ s/^(.*?)Ports..//igm;
		my @scanresult = map { s/\s+//igm; $_ } split(/,/, $output);
		@running = map { $ports{$_} } map { [split(/\//, $_)]->[0] } grep {/open/} @scanresult;
	}
	
	return @running;
}

sub hosts {
	my %hosts = ();
    for my $host (split /\s+/, `cd /etc/hosts.d/; ls`) {
        chomp $host;
        open my $h, "<", "/etc/hosts.d/".$host."/ip";
        my $ip = <$h>;
        chomp $ip;
        close $h;
        $hosts{$host} = $ip;
    }
    return %hosts;
}

sub services {
	my %services = ();
	my %ips = hosts();
    for my $host (split /\s+/, `cd /etc/hosts.d/; ls`) {
        chomp $host;
        open my $h, "<", "/etc/hosts.d/".$host."/services" or next;
        my @s = <$h>;
        close $h;
        @s = split(/[^a-z0-9:]/, join(" ", @s));
        $services{$ips{$host}} = $services{$host} = {map {$_ => 1} @s};
    }
    return %services;
}

sub set_services {
    my ($host, @services) = @_;
    open my $h, ">", "/etc/hosts.d/".$host."/services" or return;
    print $h join(" ", @services)."\n";
    close $h;
}

sub add {
	my @arg = @_;

	if (scalar @arg == 2) {
	    my $ip = $arg[0];
	    my $host = $arg[1];
	    $ip =~ s/[^a-zA-Z0-9_.-]//igm;
	    $host =~ s/[^a-zA-Z0-9_.-]//igm;
	    if ($ip =~ /[a-zA-Z]/i) {
	    	($host, $ip) = ($ip, $host);
	    }
	    
	    print "IP: " . $ip . "\n";
	    print "Host: " . $host . "\n";
	    
	    mkdir "/etc/hosts.d/".$host;
	    open my $f, ">", "/etc/hosts.d/".$host."/ip";
	    print $f $ip."\n";
	    close $f;
	}
	else {
		print STDERR "Syntax: $0 add IP HOST\n";
	}
}

sub sync {
	my @arg = @_;
	my %hosts = hosts();
	my %services = services();
	for my $host (keys %hosts) {
		next if (!$services{$host}{"ssh"});
		
		my $ip = $hosts{$host};
		for my $dir (qw(/etc/tinc/tobiasschulz/hosts/ /etc/hosts.d/)) {
			if (@arg) {
				print "$host ($ip):\n";
				system("nc -z $ip 22 && nc -z $ip 53 && (rsync -zav $ip:$dir $dir ; rsync -zav $dir $ip:$dir)");
			}
			else {
				system("nc -z $ip 22 && nc -z $ip 53 && rsync -e 'ssh -oStrictHostKeyChecking=no -oBatchMode=yes ' -za $ip:$dir $dir 2>/dev/null");
				system("nc -z $ip 22 && nc -z $ip 53 && rsync -e 'ssh -oStrictHostKeyChecking=no -oBatchMode=yes ' -za $dir $ip:$dir 2>/dev/null");
			}
		}
	}
}

sub install {
	# do not install anything when run from /etc/init.d !!
	if ($0 =~ /init.d/) {
		return;
	}
		
	{
		system("mv /etc/crontab /etc/crontab.bak; grep -v $0 /etc/crontab.bak > /etc/crontab");
		open my $f, ">>", "/etc/crontab";
		print $f '*/5 * * * * root $(dirname '.$0.')/update-motd'."\n";
		print $f '0 * * * * root '.$0.' sync'."\n";
		close $f;
	}
	unlink("/etc/update-motd.d/10-help-text");
	{
		open my $f, ">", "/etc/update-motd.d/10-hosts";
		print $f q{echo; }.$0.q{ check | perl -n -e 'print "  "; print;' 2>/dev/null}.qq{\n};
		close $f;
		system("chmod 0777 /etc/update-motd.d/10-hosts");
	}
	{
		system("rm /etc/resolv.conf");
		open my $f, ">", "/etc/resolv.conf";
		print $f qq{nameserver 127.0.1.1\nnameserver 8.8.8.8\n};
		close $f;
	}
	{
		system("rm /etc/init.d/hosts");
		open my $f, ">", "/etc/init.d/hosts";
		print $f "#!/bin/bash\n".$lsb."\n".$0.' $*'."\n";
		close $f;
		system("chmod 0777 /etc/init.d/hosts");
		system("update-rc.d hosts defaults 2>&1 | grep -v 'already exist'");
	}
	system("comment-out pam_motd.so /etc/pam.d/*");
}

init;
if (@ARGV && $ARGV[0] eq "add") {
	shift @ARGV;
	add @ARGV;
}
elsif (@ARGV && $ARGV[0] eq "sync") {
	shift @ARGV;
	sync @ARGV;
	rebuild;
}
elsif (@ARGV && $ARGV[0] eq "list") {
	list;
}
elsif (@ARGV && ($ARGV[0] eq "status" || $ARGV[0] eq "check")) {
	check;
}
elsif (@ARGV && ($ARGV[0] eq "start" || $ARGV[0] eq "restart" || $ARGV[0] eq "install")) {
    print "Starting hosts script...\n" if $ARGV[0] eq "start";
    print "Restarting hosts script...\n" if $ARGV[0] eq "restart";
	install;
	rebuild;
}
elsif (@ARGV && ($ARGV[0] eq "stop")) {
    print "Stopping hosts script...\n";
    rebuild;
}
else {
	rebuild;
}

1;
